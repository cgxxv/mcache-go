package mcache

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"strconv"
	"sync"
	"testing"
	"time"

	"github.com/alicebob/miniredis"
	"github.com/go-redis/redis/v8"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"github.com/vmihailenco/msgpack/v5"
)

func randString(l int) string {
	buf := make([]byte, l)
	for i := 0; i < (l+1)/2; i++ {
		buf[i] = byte(rand.Intn(256))
	}
	return fmt.Sprintf("%x", buf)[:l]
}

var (
	ctx       = context.TODO()
	fakeRedis *miniredis.Miniredis
	mockRedis *redis.Client
	inited    bool
)

func Init() {
	runUnitTest = true

	var err error
	fakeRedis, err = miniredis.Run()
	if err != nil {
		panic(err)
	}
	mockRedis = redis.NewClient(&redis.Options{Addr: fakeRedis.Addr()})
}

type TestC struct {
	I int64
	S string
	M map[int64][]byte
	J int64
}

type TestCH struct {
	I int64
	J int64
	S string
}

type MCacheTestSuite struct {
	suite.Suite
	simple    Cache
	simpleV   Cache
	simplerm  Cache
	simplermi Cache
	simplerm2 Cache
	simplers  Cache
	simpleri  Cache
	simplerl  Cache
	simplerd  Cache
	simplesk  Cache
	simpleM   Cache
	lrusk     Cache
	lfusk     Cache
	arcsk     Cache
	lruL      Cache
	lruV      Cache
	lruE      Cache
	lfu       Cache
	lfuV      Cache
	arc       Cache
	arcL      Cache
	mockRedis *redis.Client
	fakeRedis *miniredis.Miniredis

	msimple    Cache
	msimplef   Cache
	msimplefr  Cache
	msimplefr2 Cache

	simpleNoRedisWithLoader     Cache
	simpleNoRedisWithMLoader    Cache
	simpleWithRedisLoaderDefVal Cache

	s dataWrapper
}

func (t *MCacheTestSuite) LoadData() {
	var (
		rv  = "rv"
		rki = 1
		vs  string
		err error
		b   []byte
		v   interface{}
	)

	b, err = t.s.marshal(ctx, rv)
	assert.Nil(t.T(), err)
	t.mockRedis.Set(ctx, "rk", b, 0)
	b, err = t.mockRedis.Get(ctx, "rk").Bytes()
	assert.Nil(t.T(), err)

	v, err = t.s.unmarshal(ctx, b, &vs)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "rv", vs)
	assert.Equal(t.T(), "rv", v)

	b, _ = t.s.marshal(ctx, rki)
	t.mockRedis.Set(ctx, "rki", b, 0)
	t.mockRedis.Set(ctx, "10", b, 0)
	t.mockRedis.Set(ctx, "100", b, 0)
	b, _ = t.s.marshal(ctx, rv)
	t.mockRedis.Set(ctx, "105", b, 0)

	rkmv := map[string]int{
		"1": 1,
		"3": 4,
	}
	b, _ = t.s.marshal(ctx, rkmv)
	t.mockRedis.Set(ctx, "rkm", b, 0)

	rksv := TestC{
		I: 1,
		S: "abc",
		M: map[int64][]byte{
			1: {'a', 'b'},
			2: {'c', 'd'},
		},
		J: 2,
	}
	b, _ = t.s.marshal(ctx, rksv)
	t.mockRedis.Set(ctx, "rks", b, 0)
}

func (t *MCacheTestSuite) TearDownTest() {
	t.fakeRedis.FlushAll()
}

func (t *MCacheTestSuite) SetupTest() {
	t.fakeRedis = fakeRedis
	t.mockRedis = mockRedis
	t.s = newMsgpackSerializer()

	t.msimple = New(20)
	t.simple = New(20)
	t.simpleV = New(3)
	t.lruE = New(20, WithCacheType(TYPE_LRU))
	t.lruV = New(5, WithCacheType(TYPE_LRU))
	t.lfu = New(20, WithCacheType(TYPE_LFU))
	t.lfuV = New(5, WithCacheType(TYPE_LFU))
	t.arc = New(20, WithCacheType(TYPE_ARC))
	t.msimplef = New(20,
		WithMLoaderFn(
			func(ctx context.Context, keys []string) (map[string]interface{}, error) {
				kv := make(map[string]interface{})
				for _, key := range keys {
					kv[key] = key
				}
				return kv, nil
			}),
		WithExp(time.Second),
	)
	t.msimplefr = New(20, WithCacheType(TYPE_SIMPLE),
		WithMLoaderFn(
			func(ctx context.Context, keys []string) (map[string]interface{}, error) {
				kv := make(map[string]interface{})
				for _, key := range keys {
					kv[key] = key
				}
				return kv, nil
			}),
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(string)
		}),
		WithExp(time.Second),
	)
	t.msimplefr2 = New(20, WithCacheType(TYPE_SIMPLE),
		WithMLoaderFn(
			func(ctx context.Context, keys []string) (map[string]interface{}, error) {
				kv := make(map[string]interface{})
				for _, key := range keys {
					kv[key] = key
				}
				return kv, nil
			}),
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithExp(time.Second),
	)

	t.simpleM = New(20, WithLoaderFn(
		func(ctx context.Context, key string) (interface{}, error) {
			time.Sleep(time.Second)
			return 333333, nil
		}),
		WithExp(time.Minute),
	)

	t.lrusk = New(20, WithCacheType(TYPE_LRU),
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return 1, nil
		}),
		WithExp(time.Second),
	)

	t.lfusk = New(20, WithCacheType(TYPE_LFU),
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithLoaderFn(
			func(ctx context.Context, key string) (interface{}, error) {
				return 1, nil
			}),
		WithExp(time.Second),
	)

	t.arcsk = New(20, WithCacheType(TYPE_ARC),
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return 1, nil
		}),
		WithExp(time.Second),
	)

	t.simplesk = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return 1, nil
		}),
		WithExp(time.Second),
	)

	t.simplerd = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return nil, KeyNotFoundError
		}),
		WithDefaultVal(5),
	)

	t.simplerm2 = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(TestC)
		}),
		WithExp(time.Second),
	)

	t.simplerm = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(map[string]int)
		}),
	)

	t.simplermi = New(20,

		WithRedisOptions(&redis.Options{Addr: fakeRedis.Addr()}),
		WithSafeValPtrFn(func() interface{} {
			return new(map[string]interface{})
		}),
	)

	t.simplers = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(string)
		}),
	)

	t.simpleri = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(int)
		}),
	)

	t.simplerl = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(string)
		}),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return "v", nil
		}),
	)

	t.simpleNoRedisWithLoader = New(20,
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return s + "a", nil
		}),
		WithExp(time.Second),
	)

	t.simpleNoRedisWithMLoader = New(20,
		WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
			res := make(map[string]interface{}, len(keys))
			for _, k := range keys {
				res[k] = k + "a"
			}

			return res, nil
		}),
		WithExp(time.Second),
	)

	t.simpleWithRedisLoaderDefVal = New(20,
		WithRedisClient(t.mockRedis),
		WithSafeValPtrFn(func() interface{} {
			return new(string)
		}),
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "vvvv", nil
		}),
		WithDefaultVal("defv"),
	)

	t.lruL = New(20, WithCacheType(TYPE_LRU),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return "v", nil
		}),
	)

	t.arcL = New(5, WithCacheType(TYPE_ARC),
		WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
			return "v", nil
		}),
	)

	t.LoadData()
}

func TestLocalTestSuite(t *testing.T) {
	if !inited {
		Init()
		inited = true
	}
	suite.Run(t, new(MCacheTestSuite))
}

func (t *MCacheTestSuite) TestSimplerMI() {
	var (
		opt Option
		err error
		key string
		v   interface{}
		b   []byte
	)
	testm := map[string]interface{}{
		"a": "111",
		"b": "hello",
		"c": "zhihu",
	}
	key = "simplermi-testm"
	opt = WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
		return testm, nil
	})
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	t.simplermi.remove(key)
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	t.simplermi.remove(key)
	v, err = t.simplermi.Get(ctx, key)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)
	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))

	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.Nil(t.T(), err)
	v, err = t.simplermi.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	opt = WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
		return nil, errors.New("unexpected")
	})
	key = "simplermi-testm2"
	v, err = t.simplermi.Get(ctx, key, opt, WithDefaultVal(testm))
	assert.Equal(t.T(), DefValSetError, err)
	assert.Equal(t.T(), testm, v)

	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))
	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), b)

	key = "simplermi-testm3"
	v, err = t.simplermi.Get(ctx, key, opt, WithDefaultVal(&testm))
	assert.Equal(t.T(), DefValSetError, err)
	assert.Equal(t.T(), testm, v)

	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))
	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), b)

	opt = WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
		return &testm, nil
	})
	key = "simplermi-testm4"
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))
	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.Nil(t.T(), err)
	v, err = t.simplermi.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	t.simplermi.remove(key)
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	key = "simplermi-testm5"
	err = t.simplermi.Set(ctx, key, testm)
	assert.Nil(t.T(), err)

	t.simplermi.remove(key)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
	v, err = t.simplermi.Get(ctx, key)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)
	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))

	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.Nil(t.T(), err)
	v, err = t.simplermi.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	key = "simplermi-testm6"
	err = t.simplermi.Set(ctx, key, &testm)
	assert.Nil(t.T(), err)
	v, err = t.simplermi.Get(ctx, key)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testm, v)

	opt = WithSafeValPtrFn(func() interface{} {
		return new([]string)
	})
	tests := []string{"a", "b", "c"}
	key = "simplermi-test-strs"
	err = t.simplermi.Set(ctx, key, tests, opt)
	assert.Nil(t.T(), err)

	t.simplermi.remove(key)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), tests, v)
	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))

	b, err = t.mockRedis.Get(ctx, key).Bytes()
	assert.Nil(t.T(), err)
	v, err = t.simplermi.deserialize(ctx, b, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), tests, v)

	opt = WithSafeValPtrFn(func() interface{} {
		return make([]string, 0, 4)
	})
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), tests, v)

	t.simplermi.remove(key)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), v)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))

	opt = WithSafeValPtrFn(func() interface{} {
		return []string{}
	})
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), v)

	opt = WithSafeValPtrFn(func() interface{} {
		return new(TestC)
	})
	testStruct := TestC{
		I: 2,
		S: "abc",
		M: map[int64][]byte{
			1: {'a', 'b'},
			2: {'c', 'd'},
		},
		J: 2,
	}
	key = "simplermi-test-struct"
	err = t.simplermi.Set(ctx, key, testStruct, opt)
	assert.Nil(t.T(), err)
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testStruct, v)

	t.simplermi.remove(key)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testStruct, v)
	assert.True(t.T(), t.simplermi.HasLocal(ctx, key))

	opt = WithSafeValPtrFn(func() interface{} {
		return make([]TestC, 0, 16)
	})
	testStructs := []TestC{{
		I: 2,
		S: "abc",
		M: map[int64][]byte{
			1: {'a', 'b'},
			2: {'c', 'd'},
		},
		J: 2,
	}}
	key = "simplermi-test-structs"
	err = t.simplermi.Set(ctx, key, testStructs, opt)
	assert.Nil(t.T(), err)
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), testStructs, v)

	t.simplermi.remove(key)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
	v, err = t.simplermi.Get(ctx, key, opt)
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), v)
	assert.False(t.T(), t.simplermi.HasLocal(ctx, key))
}

func (t *MCacheTestSuite) TestSimpleNoRedisWithLoader() {

	err := t.simpleNoRedisWithLoader.Set(ctx, "1", "a")
	assert.Nil(t.T(), err)

	v, err := t.simpleNoRedisWithLoader.Get(ctx, "1",
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "1a", nil
		}),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "a", v)

	time.Sleep(time.Second)
	vExp, err := t.simpleNoRedisWithLoader.getFromLocal(ctx, "1", false)
	assert.Equal(t.T(), KeyNotFoundError, err)
	assert.Nil(t.T(), vExp)

	v1, err := t.simpleNoRedisWithLoader.Get(ctx, "2",
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "2d", nil
		}),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "2d", v1)

	time.Sleep(time.Second)
	v1Exp, err := t.simpleNoRedisWithLoader.Get(ctx, "2")
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "2a", v1Exp)

	time.Sleep(time.Second)
	v1Exp2, err := t.simpleNoRedisWithLoader.getFromLocal(ctx, "2", false)
	assert.Equal(t.T(), KeyNotFoundError, err)
	assert.Nil(t.T(), v1Exp2)
}

func (t *MCacheTestSuite) TestSimpleNoRedisWithMLoader() {

	keys1 := []string{"1", "2", "3"}
	err := t.simpleNoRedisWithMLoader.MSet(ctx, keys1, []interface{}{"a", "b", "c"})
	assert.Nil(t.T(), err)

	v, err := t.simpleNoRedisWithMLoader.MGet(ctx, keys1)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v, 3)
	assert.Equal(t.T(), "a", v["1"])
	assert.NotEqual(t.T(), "2a", v["2"])
	assert.Equal(t.T(), "c", v["3"])

	time.Sleep(time.Second)
	v1Exp, err := t.simpleNoRedisWithMLoader.MGet(ctx, keys1)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v1Exp, 3)
	assert.Equal(t.T(), "1a", v1Exp["1"])
	assert.Equal(t.T(), "2a", v1Exp["2"])
	assert.Equal(t.T(), "3a", v1Exp["3"])

	time.Sleep(time.Second)
	v1exp2, err := t.simpleNoRedisWithMLoader.MGet(ctx, keys1,
		WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
			res := make(map[string]interface{}, len(keys))
			for _, k := range keys {
				res[k] = k + "aaa"
			}

			return res, nil
		}), WithExp(2*time.Second),
	)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v1Exp, 3)
	assert.Equal(t.T(), "1aaa", v1exp2["1"])
	assert.Equal(t.T(), "2aaa", v1exp2["2"])
	assert.Equal(t.T(), "3aaa", v1exp2["3"])

	time.Sleep(time.Second)
	v1exp3, err := t.simpleNoRedisWithMLoader.MGet(ctx, keys1)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v1Exp, 3)
	assert.Equal(t.T(), "1aaa", v1exp3["1"])
	assert.Equal(t.T(), "2aaa", v1exp3["2"])
	assert.Equal(t.T(), "3aaa", v1exp3["3"])

	v1exp4, err := t.simpleNoRedisWithMLoader.Get(ctx, "3")
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "3aaa", v1exp4)

	time.Sleep(time.Second)
	v1exp4, err = t.simpleNoRedisWithMLoader.Get(ctx, "3")

	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), v1exp4)
}

func (t *MCacheTestSuite) TestSimpleConcurrently() {
	b, err := t.mockRedis.Get(ctx, "100").Bytes()
	assert.Nil(t.T(), err)
	vi, err := t.simplesk.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, vi)

	var (
		valPtrOpt = WithSafeValPtrFn(func() interface{} {
			return new(string)
		})
	)

	key := randString(5)
	v, err := t.simplesk.Get(ctx, key, valPtrOpt)
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), v)

	v, err = t.simplesk.Get(ctx, key, valPtrOpt, WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
		return "hello", nil
	}))
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "hello", v)

	var (
		keys []string
		vals []string

		wg   sync.WaitGroup
		cset = func(i int) {
			defer wg.Done()

			key := keys[i]
			val := vals[i]
			err := t.simplesk.Set(ctx, key, val, WithExp(5*time.Minute))
			assert.NotNil(t.T(), err)

			loaderFnOpt := WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
				return val, nil
			})

			err = t.simplesk.Set(ctx, key, val, valPtrOpt, loaderFnOpt)
			assert.Nil(t.T(), err)

			b, err := t.mockRedis.Get(ctx, key).Bytes()
			assert.Nil(t.T(), err)
			assert.NotNil(t.T(), b)

			var ss string
			err = msgpack.Unmarshal(b, &ss)
			assert.Nil(t.T(), err)
			assert.Equal(t.T(), val, ss)
		}

		cget = func(i int) {
			defer wg.Done()

			key := keys[i]
			val := vals[i]
			loaderFnOpt := WithLoaderFn(func(ctx context.Context, key string) (interface{}, error) {
				return val, nil
			})

			if t.simplesk.HasLocal(ctx, key) {
				t.simplesk.remove(key)
			}

			v, err := t.simplesk.Get(ctx, key, valPtrOpt, loaderFnOpt)
			assert.Nil(t.T(), err)
			assert.Equal(t.T(), val, v)

			b, err := t.mockRedis.Get(ctx, key).Bytes()
			assert.Nil(t.T(), err)
			assert.NotNil(t.T(), b)

			var ss string
			err = msgpack.Unmarshal(b, &ss)
			assert.Nil(t.T(), err)
			assert.Equal(t.T(), val, ss)
		}
	)
	for i := 0; i < 20; i++ {
		keys = append(keys, randString(i+5))
		vals = append(vals, randString(i+5))
	}

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go cset(i)
	}

	for i := 10; i < 20; i++ {
		wg.Add(1)
		go cget(i)
	}

	for i := 5; i < 15; i++ {
		for j := 0; j < 10; j++ {
			wg.Add(2)
			go cset(i)
			go cget(i)
		}
	}
	wg.Wait()
}

func (t *MCacheTestSuite) TestSimpleMConcurrently() {
	const runTimes = 10
	var (
		valPtrOpt = WithSafeValPtrFn(func() interface{} {
			return new(string)
		})
		wg   sync.WaitGroup
		keys []string
		vals []interface{}
	)
	for i := 0; i < runTimes; i++ {
		keys = append(keys, randString(i+5+rand.Intn(5)))
		vals = append(vals, randString(i+5+rand.Intn(5)))
	}

	var kvs = make(map[string]interface{}, len(keys))
	for i := 0; i < len(keys); i++ {
		kvs[keys[i]] = vals[i]
	}

	for i := 0; i < runTimes; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()

			err := t.simplesk.MSet(ctx, keys, vals, valPtrOpt)
			assert.Nil(t.T(), err)

			rs, err := t.mockRedis.MGet(ctx, keys...).Result()
			assert.Nil(t.T(), err)
			assert.Len(t.T(), rs, len(vals))

			var ss string
			for j := 0; j < len(rs); j++ {
				err = msgpack.Unmarshal([]byte(rs[j].(string)), &ss)
				assert.Nil(t.T(), err)
				assert.Equal(t.T(), vals[j], ss)
			}
		}()
	}

	for i := 0; i < runTimes; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()

			mloaderOpt := WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
				res := make(map[string]interface{}, len(keys))
				for i := 0; i < len(keys); i++ {
					res[keys[i]] = kvs[keys[i]]
				}

				return res, nil
			})

			for _, key := range keys {

				t.simplesk.remove(key)
			}

			ms, err := t.simplesk.MGet(ctx, keys, valPtrOpt, mloaderOpt)
			assert.Nil(t.T(), err)
			assert.Len(t.T(), ms, len(keys))
			assert.Equal(t.T(), kvs, ms)

			rs, err := t.mockRedis.MGet(ctx, keys...).Result()
			assert.Nil(t.T(), err)
			assert.Len(t.T(), rs, len(vals))

			var ss string
			for i := range keys {
				val := vals[i]
				err = msgpack.Unmarshal([]byte(rs[i].(string)), &ss)
				assert.Nil(t.T(), err)
				assert.Equal(t.T(), val, ss)
			}
		}()
	}
	wg.Wait()
}

func (t *MCacheTestSuite) TestMSimpleM() {
	b, err := t.mockRedis.Get(ctx, "100").Bytes()
	assert.Nil(t.T(), err)
	vi, err := t.simpleri.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, vi)

	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()

			v, _ := t.msimplefr.MGet(ctx, []string{"105", "101", "102", "103", "104"})
			assert.Equal(t.T(), map[string]interface{}{"105": "rv", "101": "101", "102": "102", "103": "103", "104": "104"}, v)
		}()
	}
	wg.Wait()

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			v, _ := t.msimplef.MGet(ctx, []string{"1", "2", "3", "4", "5"})
			assert.Equal(t.T(), map[string]interface{}{"1": "1", "2": "2", "3": "3", "4": "4", "5": "5"}, v)
		}()
	}
	wg.Wait()

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			t.msimplef.MGet(ctx, []string{"6", "7", "8", "9", "10"}, WithExp(2*time.Second), WithIsWait(false))
		}()
	}
	wg.Wait()
	time.Sleep(time.Second)
	dd, _ := t.msimplef.MGet(ctx, []string{"6", "7", "8", "9", "10"}, WithIsWait(false))

	assert.Equal(t.T(), map[string]interface{}{"6": "6", "7": "7", "8": "8", "9": "9", "10": "10"}, dd)
}

func (t *MCacheTestSuite) TestMSimpleFR() {

	v, _ := t.msimplefr.MGet(ctx, []string{"5", "6", "7", "8"})
	assert.Len(t.T(), v, 4)
	assert.Equal(t.T(), "8", v["8"])

	bs, err := t.fakeRedis.Get("5")
	assert.Nil(t.T(), err)
	vs, err := t.msimplefr.deserialize(ctx, []byte(bs))
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "5", vs)

	b, err := t.mockRedis.Get(ctx, "7").Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "7", vs)
	valCacheExp, err := t.mockRedis.TTL(ctx, "7").Result()
	assert.Equal(t.T(), 1*time.Second, valCacheExp)

	b, err = t.mockRedis.Get(ctx, "7").Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, b)
	assert.Equal(t.T(), "7", vs)

	assert.True(t.T(), t.msimplefr.HasLocal(ctx, "8"))
	assert.False(t.T(), t.msimplefr.HasLocal(ctx, "9"))
	assert.False(t.T(), t.msimplefr.HasLocal(ctx, "10"))

	v, err = t.msimplefr.MGet(ctx, []string{"9", "8", "10"})
	assert.Len(t.T(), v, 3)
	assert.Equal(t.T(), "10", v["10"])

	v, err = t.msimplefr.MGet(ctx, []string{"9", "8"})
	assert.Len(t.T(), v, 2)
	assert.Equal(t.T(), "9", v["9"])
	assert.Equal(t.T(), "8", v["8"])

	vLocal, err := t.msimplefr.getFromLocal(ctx, "9", false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "9", vLocal)
}

func (t *MCacheTestSuite) TestMSimpleF() {

	v, _ := t.msimplef.MGet(ctx, []string{"1", "2", "3", "4"})
	assert.Len(t.T(), v, 4)
	assert.Equal(t.T(), "3", v["3"])

	v, _ = t.msimplef.MGet(ctx, []string{"2", "3", "4", "5"})
	assert.Len(t.T(), v, 4)
	assert.Equal(t.T(), "5", v["5"])

	time.Sleep(time.Second)
	v, _ = t.msimplef.MGet(ctx, []string{"1", "2"})
	assert.Len(t.T(), v, 2)
	assert.Equal(t.T(), "1", v["1"])

	v2, err := t.msimplef.Get(ctx, "3")

	assert.Equal(t.T(), KeyNotFoundError, err)
	assert.Equal(t.T(), nil, v2)
	v2Str, ok := v2.(string)
	assert.False(t.T(), ok)
	assert.Equal(t.T(), "", v2Str)
}

func (t *MCacheTestSuite) TestMSimple() {

	var mgetKeys = []string{"1", "2", "3", "4"}

	v, _ := t.msimple.MGet(ctx, mgetKeys)
	assert.Len(t.T(), v, 0)
	t.msimple.MSet(ctx, []string{"1", "3", "5"}, []interface{}{"a", "c", "e"})
	v, _ = t.msimple.MGet(ctx, mgetKeys)
	assert.Len(t.T(), v, 2)
	assert.Equal(t.T(), "a", v["1"])
	assert.Equal(t.T(), "c", v["3"])

	err := t.msimple.MSet(ctx, []string{"4"}, []interface{}{"d"}, WithExp(time.Second))
	assert.Nil(t.T(), err)
	v2, _ := t.msimple.MGet(ctx, []string{"3", "4"})
	assert.Len(t.T(), v2, 2)
	assert.Equal(t.T(), "d", v2["4"])
	assert.Equal(t.T(), "c", v2["3"])

	time.Sleep(time.Second)
	v3, _ := t.msimple.MGet(ctx, mgetKeys)

	assert.Len(t.T(), v3, 2)
	assert.Equal(t.T(), "a", v3["1"])
	assert.Equal(t.T(), "c", v3["3"])

	v4, err := t.msimple.Get(ctx, "4",
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "4hahaha", nil
		}),
		WithExp(2*time.Second),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "4hahaha", v4)

	time.Sleep(1 * time.Second)
	v4Exp, err := t.msimple.getFromLocal(ctx, "4", false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "4hahaha", v4Exp)

	time.Sleep(1 * time.Second)
	v4Exp2, err := t.msimple.Get(ctx, "4")
	assert.Equal(t.T(), KeyNotFoundError, err)
	assert.Equal(t.T(), nil, v4Exp2)

	v5, err := t.msimple.MGet(ctx, []string{"5", "6", "7"},
		WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
			res := make(map[string]interface{}, len(keys))
			for _, s := range keys {
				res[s] = s + "d"
			}

			return res, nil
		}),
		WithExp(1*time.Second),
	)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v5, 3)
	assert.Equal(t.T(), "e", v5["5"])
	assert.Equal(t.T(), "6d", v5["6"])
	assert.Equal(t.T(), "7d", v5["7"])

	time.Sleep(time.Second)
	v5Exp, err := t.msimple.MGet(ctx, []string{"5", "6", "7"})
	assert.Nil(t.T(), err)
	assert.Len(t.T(), v5Exp, 1)
	assert.Equal(t.T(), "e", v5Exp["5"])
}

func (t *MCacheTestSuite) TestLRUV() {

	for i := 0; i < defaultShardCap; i++ {
		t.lruV.Set(ctx, strconv.FormatInt(int64(i), 10), i)
	}

	for i := 0; i < defaultShardCap; i++ {
		t.lruV.Get(ctx, strconv.FormatInt(int64(i), 10))
	}

	t.lruV.Set(ctx, strconv.FormatInt(int64(defaultShardCap), 10), defaultShardCap)
	assert.False(t.T(), t.lruV.HasLocal(ctx, "0"))
}

func (t *MCacheTestSuite) TestLFUV() {

	for i := 0; i < defaultShardCap; i++ {
		t.lfuV.Set(ctx, strconv.FormatInt(int64(i), 10), i)
	}

	for i := 0; i < defaultShardCap; i++ {
		t.lfuV.Get(ctx, strconv.FormatInt(int64(i), 10))
	}

	for i := 0; i < defaultShardCap; i++ {
		if i == 1 {
			continue
		}
		t.lfuV.Get(ctx, strconv.FormatInt(int64(i), 10))
	}

	t.lfuV.Set(ctx, strconv.FormatInt(int64(defaultShardCap), 10), defaultShardCap)
	assert.False(t.T(), t.lfuV.HasLocal(ctx, "1"))
}

func (t *MCacheTestSuite) TestSimpleET() {

	err := t.simpleV.Set(ctx, "1", 1, WithExp(time.Minute))
	assert.Nil(t.T(), err)
	err = t.simpleV.Set(ctx, "2", 2, WithExp(time.Second))
	assert.Nil(t.T(), err)
	err = t.simpleV.Set(ctx, "0", 0, WithExp(time.Hour))
	assert.Nil(t.T(), err)
	for i := 0; i < 3; i++ {
		assert.True(t.T(), t.simpleV.HasLocal(ctx, strconv.FormatInt(int64(i), 10)))
	}
	var (
		keys = []string{"0", "1", "2"}
		vals = []int{0, 1, 2}
		kvs  = map[string]interface{}{"0": 0, "1": 1, "2": 2}
		res  map[string]interface{}
	)
	res, err = t.simpleV.MGet(ctx, keys)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), res, len(keys))

	err = t.simpleV.Set(ctx, "3", 3, WithExp(time.Minute))
	assert.Nil(t.T(), err)
	for i := 0; i < 4; i++ {
		assert.True(t.T(), t.simpleV.HasLocal(ctx, strconv.FormatInt(int64(i), 10)))
	}
	keys = append(keys, "3")
	vals = append(vals, 3)
	kvs["3"] = 3

	res, err = t.simpleV.MGet(ctx, keys)
	assert.Nil(t.T(), err)
	assert.Len(t.T(), res, len(keys))
	assert.Equal(t.T(), kvs, res)

	time.Sleep(time.Second)
	err = t.simpleV.Set(ctx, "4", 4, WithExp(time.Minute))
	assert.False(t.T(), t.simpleV.HasLocal(ctx, "2"))

	v, err := t.simpleV.Get(ctx, "5",
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "55555", nil
		}),
		WithExp(time.Second),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "55555", v)

	time.Sleep(time.Second)
	assert.False(t.T(), t.simpleV.HasLocal(ctx, "5"))
}

func (t *MCacheTestSuite) TestSimpleRedisSK() {

	tch := TestCH{
		I: 2,
		S: "abc",
		J: 2,
	}
	jTch, _ := msgpack.Marshal(&tch)

	val, _ := t.simplesk.Get(ctx, string(jTch))
	assert.Equal(t.T(), 1, val)

	b, err := t.mockRedis.Get(ctx, string(jTch)).Bytes()
	assert.Nil(t.T(), err)
	vi, err := t.simplesk.deserialize(ctx, b)
	assert.Equal(t.T(), 1, vi)
	redisExp, err := t.mockRedis.TTL(ctx, string(jTch)).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, redisExp)

	val, _ = t.simplesk.getFromLocal(ctx, string(jTch), false)
	assert.Equal(t.T(), 1, val)

	time.Sleep(1 * time.Second)

	t.mockRedis.Expire(ctx, string(jTch), 0)

	val, _ = t.simplesk.Get(ctx, string(jTch))
	assert.Equal(t.T(), 1, val)

	time.Sleep(1 * time.Second)
	t.mockRedis.Expire(ctx, string(jTch), 0)

	val2, err := t.simplesk.Get(ctx, string(jTch),
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return 2, nil
		}),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 2, val2)

	val2Local, err := t.simplesk.getFromLocal(ctx, string(jTch), false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 2, val2Local)

	b, err = t.mockRedis.Get(ctx, string(jTch)).Bytes()
	assert.Nil(t.T(), err)
	val2Cache, err := t.simplesk.deserialize(ctx, b)
	assert.Equal(t.T(), 2, val2Cache)

	time.Sleep(1 * time.Second)
	t.mockRedis.Expire(ctx, string(jTch), 0)

	val3, err := t.simplesk.Get(ctx, string(jTch),
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return 3, nil
		}),
		WithExp(2*time.Minute),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 3, val3)

	val3Local, err := t.simplesk.getFromLocal(ctx, string(jTch), false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 3, val3Local)
	b, err = t.mockRedis.Get(ctx, string(jTch)).Bytes()
	assert.Nil(t.T(), err)
	val3Cache, err := t.simplesk.deserialize(ctx, b)
	assert.Equal(t.T(), 3, val3Cache)

	redisExp3, err := t.mockRedis.TTL(ctx, string(jTch)).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 120*time.Second, redisExp3)
}

func (t *MCacheTestSuite) TestSimpleRedisL() {
	val, _ := t.simplerl.Get(ctx, "rkl")
	assert.Equal(t.T(), "v", val)
	b, err := t.mockRedis.Get(ctx, "rkl").Bytes()
	assert.Nil(t.T(), err)
	vsr, err := t.simplerl.deserialize(ctx, b)

	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "v", vsr)
}

func (t *MCacheTestSuite) TestSimpleRedis() {
	bs, err := t.mockRedis.Get(ctx, "rk").Bytes()
	assert.Nil(t.T(), err)
	assert.NotNil(t.T(), t.simplers)
	vs, err := t.simplers.deserialize(ctx, bs)
	assert.Equal(t.T(), "rv", vs)

	val, err := t.simplers.Get(ctx, "rk")
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "rv", val)

	val, _ = t.simpleri.Get(ctx, "rki")
	assert.Equal(t.T(), 1, val)

	val, _ = t.simpleri.Get(ctx, "rki")
	assert.Equal(t.T(), 1, val)

	val2, err := t.simpleri.Get(ctx, "rki", WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
		return "ddd", nil
	}), WithSafeValPtrFn(func() interface{} {
		return new(string)
	}))
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, val2)

	val3, err := t.simpleri.Get(ctx, "rki2",
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return "dfs", nil
		}),
		WithSafeValPtrFn(func() interface{} {
			return new(string)
		}),
		WithExp(time.Minute),
	)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "dfs", val3)

	val3Local, err := t.simpleri.getFromLocal(ctx, "rki2", false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "dfs", val3Local)

	bbs, err := t.fakeRedis.Get("rki2")
	assert.Nil(t.T(), err)
	b, err := t.mockRedis.Get(ctx, "rki2").Bytes()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), []byte(bbs), b)

	val3Redis, err := t.simplers.deserialize(ctx, b)
	assert.Equal(t.T(), "dfs", val3Redis)

	val3Exp, err := t.mockRedis.TTL(ctx, "rki2").Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 60*time.Second, val3Exp)

	t.simplerm2.Set(ctx, "rks", TestC{
		I: 2,
		S: "abc",
		M: map[int64][]byte{
			1: {'a', 'b'},
			2: {'c', 'd'},
		},
		J: 2,
	})
	val, _ = t.simplerm2.Get(ctx, "rks")
	assert.Equal(t.T(), int64(2), val.(TestC).I)
	assert.Equal(t.T(), "abc", val.(TestC).S)
	assert.Equal(t.T(), int64(2), val.(TestC).J)

	t.fakeRedis.FastForward(2 * time.Second)
	time.Sleep(2 * time.Second)

	val, err = t.simplerm2.Get(ctx, "rks")
	assert.NotNil(t.T(), err)
	assert.Nil(t.T(), val)

	time.Sleep(2 * time.Second)
	t.mockRedis.Del(ctx, "rks")
	_, err = t.simplerm2.Get(ctx, "rks")
	assert.NotNil(t.T(), err)

	val, _ = t.simplerm.Get(ctx, "rkm")
	assert.Equal(t.T(), 1, val.(map[string]int)["1"])
	assert.Equal(t.T(), 4, val.(map[string]int)["3"])
}

func (t *MCacheTestSuite) TestSimpleWithRedisLoaderFunc() {

	k1 := "TestSimpleWithRedisLoaderFunc-t1"
	err := t.simplerl.Set(ctx, k1, "v1", WithExp(2*time.Second))
	assert.Nil(t.T(), err)

	vLocal, err := t.simplerl.getFromLocal(ctx, k1, false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "v1", vLocal)

	b, err := t.mockRedis.Get(ctx, k1).Bytes()
	assert.Nil(t.T(), err)
	vRedis, err := t.simplerl.deserialize(ctx, b)
	assert.Equal(t.T(), "v1", vRedis)
	vRedisExp, err := t.mockRedis.TTL(ctx, k1).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 2*time.Second, vRedisExp)

	time.Sleep(3 * time.Second)
	t.fakeRedis.FastForward(3 * time.Second)
	vRedisExp2, err := t.mockRedis.TTL(ctx, k1).Result()

	assert.Nil(t.T(), err)
	assert.Equal(t.T(), -2*time.Nanosecond, vRedisExp2)

	val1, err := t.simplerl.Get(ctx, k1, WithExp(time.Second))
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "v", val1)

	b, err = t.mockRedis.Get(ctx, k1).Bytes()
	assert.Nil(t.T(), err)
	val1Redis, err := t.simplerl.deserialize(ctx, b)
	assert.Equal(t.T(), "v", val1Redis)
	val1RedisExp, err := t.mockRedis.TTL(ctx, k1).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, val1RedisExp)

	time.Sleep(time.Second)
	t.fakeRedis.FastForward(1 * time.Second)
	val2Local, err := t.simplerl.getFromLocal(ctx, k1, false)
	assert.Equal(t.T(), KeyNotFoundError, err)
	assert.Nil(t.T(), val2Local)

	val2, err := t.simplerl.Get(ctx, k1, WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
		return "v2", nil
	}))
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "v2", val2)

	b, err = t.mockRedis.Get(ctx, k1).Bytes()
	assert.Nil(t.T(), err)
	val2Redis, err := t.simplerl.deserialize(ctx, b)
	assert.Equal(t.T(), "v2", val2Redis)

	val2RedisExp, err := t.mockRedis.TTL(ctx, k1).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), -1*time.Nanosecond, val2RedisExp)

	val3, err := t.simplerl.MGet(ctx, []string{k1, "TestSimpleWithRedisLoaderFunc-t2", "TestSimpleWithRedisLoaderFunc-t3"})
	assert.Nil(t.T(), err)
	assert.Len(t.T(), val3, 1)
	assert.Equal(t.T(), "v2", val3["TestSimpleWithRedisLoaderFunc-t1"])

	val4, err := t.simplerl.MGet(ctx, []string{k1, "TestSimpleWithRedisLoaderFunc-t2", "TestSimpleWithRedisLoaderFunc-t3"},
		WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
			res := make(map[string]interface{}, len(keys))
			for _, k := range keys {
				if k == "TestSimpleWithRedisLoaderFunc-t2" {
					res[k] = "v22"
				}
			}

			return res, nil
		}))
	assert.Nil(t.T(), err)
	assert.Len(t.T(), val4, 2)
	assert.Equal(t.T(), "v2", val4["TestSimpleWithRedisLoaderFunc-t1"])
	assert.Equal(t.T(), "v22", val4["TestSimpleWithRedisLoaderFunc-t2"])
}

func (t *MCacheTestSuite) TestSimpleWithRedisMLoaderFunc() {

	k1 := "TestSimpleWithRedisMLoaderFunc-t1"
	v1 := "v1"
	k2 := "TestSimpleWithRedisMLoaderFunc-t2"
	v2 := "v2"
	k3 := "TestSimpleWithRedisMLoaderFunc-t3"
	v3 := "v3"
	err := t.msimplefr.MSet(ctx, []string{k1, k2, k3}, []interface{}{v1, v2, v3}, WithExp(3*time.Second))

	valLocal, err := t.msimplefr.getFromLocal(ctx, k1, false)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), v1, valLocal)

	time.Sleep(200 * time.Millisecond)
	valRedis, err := t.mockRedis.Get(ctx, k2).Bytes()
	assert.Nil(t.T(), err)
	vs, err := t.msimplefr.deserialize(ctx, valRedis)
	assert.Equal(t.T(), v2, vs)
	valRedisExp, err := t.mockRedis.TTL(ctx, k3).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 3*time.Second, valRedisExp)

	time.Sleep(3 * time.Second)
	t.fakeRedis.FastForward(3 * time.Second)
	val1HasLocal := t.msimplefr.HasLocal(ctx, k1)
	assert.False(t.T(), val1HasLocal)

	val1RedisExp, err := t.mockRedis.TTL(ctx, k3).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), time.Duration(-2), val1RedisExp)

	val2, err := t.msimplefr.MGet(ctx, []string{k1, k2, k3}, WithExp(2*time.Second))
	assert.Nil(t.T(), err)
	assert.Len(t.T(), val2, 3)
	assert.Equal(t.T(), k2, val2[k2])

	val2Redisk1, err := t.mockRedis.Get(ctx, k1).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val2Redisk1)
	assert.Equal(t.T(), k1, vs)
	val2Redisk2, err := t.mockRedis.Get(ctx, k2).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val2Redisk2)
	assert.Equal(t.T(), k2, vs)
	val2Redisk3, err := t.mockRedis.Get(ctx, k3).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val2Redisk3)
	assert.Equal(t.T(), k3, vs)

	time.Sleep(time.Second)
	assert.True(t.T(), t.msimplefr.HasLocal(ctx, k1))

	time.Sleep(2 * time.Second)
	t.fakeRedis.FastForward(2 * time.Second)

	val3, err := t.msimplefr.MGet(ctx, []string{k1, k2, k3}, WithMLoaderFn(func(ctx context.Context, keys []string) (map[string]interface{}, error) {
		res := make(map[string]interface{}, len(keys))
		for _, k := range keys {
			res[k] = k + "dd"
		}

		return res, nil
	}))
	assert.Nil(t.T(), err)
	assert.Len(t.T(), val3, 3)
	assert.Equal(t.T(), k1+"dd", val3[k1])
	assert.Equal(t.T(), k2+"dd", val3[k2])
	assert.Equal(t.T(), k3+"dd", val3[k3])

	val3Redisk1, err := t.mockRedis.Get(ctx, k1).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val3Redisk1)
	assert.Equal(t.T(), k1+"dd", vs)
	val3Redisk2, err := t.mockRedis.Get(ctx, k2).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val3Redisk2)
	assert.Equal(t.T(), k2+"dd", vs)
	val3Redisk3, err := t.mockRedis.Get(ctx, k3).Bytes()
	assert.Nil(t.T(), err)
	vs, err = t.msimplefr.deserialize(ctx, val3Redisk3)
	assert.Equal(t.T(), k3+"dd", vs)
	val3RedisExp, err := t.mockRedis.TTL(ctx, k2).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, val3RedisExp)
}

func (t *MCacheTestSuite) TestSimple() {
	val, err := t.simple.Get(ctx, "key")
	assert.NotNil(t.T(), err)

	t.simple.Set(ctx, "key", "value")
	val, err = t.simple.Get(ctx, "key")
	assert.Equal(t.T(), "value", val)

	t.simple.Set(ctx, "k", "v", WithExp(time.Second))
	val, _ = t.simple.Get(ctx, "k")
	assert.Equal(t.T(), "v", val)

	time.Sleep(time.Second)

	_, err = t.simple.Get(ctx, "k")
	assert.NotNil(t.T(), err)

	t.simple.Set(ctx, "kf", 0.01)
	val, _ = t.simple.Get(ctx, "kf")
	assert.Equal(t.T(), 0.01, val)
}

func (t *MCacheTestSuite) TestLRU() {
	v, err := t.lruL.Get(ctx, "k")
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), "v", v)

	t.lruE.Set(ctx, "k", "vv", WithExp(time.Second))
	v, _ = t.lruE.Get(ctx, "k")
	assert.Equal(t.T(), "vv", v)

	time.Sleep(time.Second)
	_, err = t.lruE.Get(ctx, "k")
	assert.NotNil(t.T(), err)
}

func (t *MCacheTestSuite) TestLFU() {
	_, err := t.lfu.Get(ctx, "k")
	assert.NotNil(t.T(), err)

	t.lfu.Set(ctx, "k", "vv", WithExp(time.Second))
	v, _ := t.lfu.Get(ctx, "k")
	assert.Equal(t.T(), "vv", v)

	time.Sleep(time.Second)
	_, err = t.lfu.Get(ctx, "k")
	assert.NotNil(t.T(), err)
}

func (t *MCacheTestSuite) TestARC() {
	v, _ := t.arcL.Get(ctx, "k")
	assert.Equal(t.T(), "v", v)

	t.arc.Set(ctx, "k", "vv", WithExp(time.Second))
	v, _ = t.arc.Get(ctx, "k")
	assert.Equal(t.T(), "vv", v)

	time.Sleep(time.Second)
	_, err := t.arc.Get(ctx, "k")
	assert.NotNil(t.T(), err)

	var (
		keys []string
		vals []interface{}
		kvs  = make(map[string]interface{})

		res map[string]interface{}
	)
	for i := 0; i < 6; i++ {
		key := randString(i + 5)
		val := randString(i + 5)
		keys = append(keys, key)
		vals = append(vals, val)
		kvs[key] = val
	}

	for i, key := range keys {
		err = t.arcL.Set(ctx, key, vals[i])
		assert.Nil(t.T(), err)
	}
	res, err = t.arcL.MGet(ctx, keys)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), kvs, res)
	assert.Len(t.T(), res, 6)
}

func (t *MCacheTestSuite) TestLRURedisSK() {

	tchObj := TestCH{
		I: 2,
		S: "abc",
		J: 2,
	}
	jTch, _ := msgpack.Marshal(&tchObj)
	tch := string(jTch)

	val, _ := t.lrusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)

	b, err := t.mockRedis.Get(ctx, tch).Bytes()
	assert.Nil(t.T(), err)
	vi, err := t.lrusk.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, vi)
	valExp, err := t.mockRedis.TTL(ctx, tch).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, valExp)

	val, _ = t.lrusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)

	time.Sleep(1 * time.Second)
	t.fakeRedis.FastForward(2 * time.Second)

	val, _ = t.lrusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)
}

func (t *MCacheTestSuite) TestLFURedisSK() {

	tchObj := TestCH{
		I: 2,
		S: "abc",
		J: 2,
	}
	jTch, _ := msgpack.Marshal(&tchObj)
	tch := string(jTch)

	val, _ := t.lfusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)
	b, err := t.mockRedis.Get(ctx, tch).Bytes()
	assert.Nil(t.T(), err)
	vi, err := t.lfusk.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, vi)
	valExp, err := t.mockRedis.TTL(ctx, tch).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, valExp)

	val, _ = t.lfusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)

	time.Sleep(1 * time.Second)
	t.fakeRedis.FastForward(2 * time.Second)

	val, _ = t.lfusk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)
}

func (t *MCacheTestSuite) TestARCRedisSK() {

	tchObj := TestCH{
		I: 2,
		S: "abc",
		J: 2,
	}
	jTch, _ := msgpack.Marshal(&tchObj)
	tch := string(jTch)

	val, err := t.arcsk.Get(ctx, tch)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, val)

	b, err := t.mockRedis.Get(ctx, tch).Bytes()
	vi, err := t.arcsk.deserialize(ctx, b)
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1, vi)
	valExp, err := t.mockRedis.TTL(ctx, tch).Result()
	assert.Nil(t.T(), err)
	assert.Equal(t.T(), 1*time.Second, valExp)

	val, _ = t.arcsk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)

	time.Sleep(1 * time.Second)
	t.fakeRedis.FastForward(2 * time.Second)

	val, _ = t.arcsk.Get(ctx, tch)
	assert.Equal(t.T(), 1, val)
}

func (t *MCacheTestSuite) TestSimpleM() {

	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			v, _ := t.simpleM.Get(ctx, "5")
			assert.Equal(t.T(), 333333, v)
		}()
	}
	wg.Wait()
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			t.simpleM.Get(ctx, "2", WithIsWait(false))
		}()
	}
	wg.Wait()
	time.Sleep(2 * time.Second)
	dd, _ := t.simpleM.Get(ctx, "2", WithIsWait(false))
	assert.Equal(t.T(), 333333, dd)
}

func (t *MCacheTestSuite) TestSimpleWithRedisLoaderDefVal() {

	key := "TestSimpleWithRedisLoaderDefVal-k1"
	key2 := "TestSimpleWithRedisLoaderDefVal-k2"
	val, err := t.simpleWithRedisLoaderDefVal.Get(ctx, key,
		WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
			return nil, errors.New("error")
		}),
	)
	assert.Equal(t.T(), DefValSetError, err)
	assert.Equal(t.T(), "defv", val)

	val2, err := t.simpleWithRedisLoaderDefVal.Get(ctx, key2, WithLoaderFn(func(ctx context.Context, s string) (interface{}, error) {
		return nil, errors.New("error2")
	}), WithDefaultVal("optDefVal"))
	assert.Equal(t.T(), DefValSetError, err)
	assert.Equal(t.T(), "optDefVal", val2)
}
